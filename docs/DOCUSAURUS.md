Integrating Docusaurus Documentation for OpenSecret-SDK

Step 1: Set Up Docusaurus in the /website Directory
	1.	Initialize Docusaurus: Create a new Docusaurus project inside the website folder at the root of your repository. For example, run the Docusaurus installer from the repo root:

npx create-docusaurus@latest website classic

This will generate a /website directory containing a Docusaurus site (with its own package.json, docusaurus.config.js, docs/ folder, etc.). You can also set this up manually by copying the Docusaurus template into /website. Make sure the website folder is separate from your SDK source code (e.g. your TypeScript code remains in the repository root or in language-specific subfolders).

	2.	Configure Site Metadata: Open website/docusaurus.config.js and update basic settings:
	•	Set the title (project name) and tagline for your documentation site.
	•	Set the url to your documentation site URL (e.g. https://docs.yourdomain.com) and baseUrl to "/" if the docs will be served at the root of that domain. For now, this can be a placeholder (you will update it to the custom domain once ready to deploy).
	•	Ensure the organizationName and projectName are set (used for things like editing links if enabled).
	•	Leave the presets (especially the "classic" preset with docs plugin) as default for now, with sidebarPath configured (usually already set to sidebars.js).
	3.	Install Dependencies: Inside website, install Docusaurus and any needed dependencies. If you used create-docusaurus, this is done for you. Otherwise, run npm install (or yarn) to install the Docusaurus packages. You will also add additional plugins in a later step.
Project Structure: After this step, your repository might look like:

OpenSecret-SDK/
??? src/                 (TypeScript SDK source code)
??? package.json         (SDK package file)
??? tsconfig.json        (TypeScript config for SDK)
??? website/
    ??? docs/            (documentation pages)
    ??? docusaurus.config.js
    ??? sidebars.js
    ??? package.json     (Docusaurus website dependencies)
    ??? ... other config and files ...

This separation keeps the docs site code isolated from the SDK code for clarity ?.

Step 2: Create a “Getting Started” Page
	1.	Add Documentation Content: In the website/docs folder, create a Markdown file for your Getting Started guide, for example getting-started.md. This will be the introductory documentation for using the OpenSecret SDK. Include a title in the front matter and some basic usage info. For example, the file might start with:

---
title: Getting Started
slug: /
--- 

# Getting Started with OpenSecret SDK

Welcome to the OpenSecret SDK. This guide will help you set up ...

Using slug: / in the front matter of the main page will make it the root docs page (so that docs/ URL shows this page).

	2.	Organize in Sidebar: By default, Docusaurus will create a sidebar from the docs folder structure automatically ?. If you have just one or two docs, you can keep it simple and let Docusaurus autogenerate the sidebar. Each Markdown file in docs becomes a doc link, and subfolders become categories in the sidebar by default ?. In our case, a single getting-started.md at the root of docs will appear as a top-level doc (or you can put it in a folder and it would become a category).
	•	If you want explicit control, edit website/sidebars.js (or sidebars.ts) to define the sidebar structure. For example, you could create a category for “Guide” and list the “Getting Started” page in it. However, for now, the default autogenerated sidebar is sufficient for a clean start.
	3.	Verify Locally: Run the development server to preview the docs site:

cd website
npm run start

Open http://localhost:3000 – you should see your documentation site with the “Getting Started” page in the sidebar and content.

Step 3: Integrate TypeDoc for TypeScript API Reference

The goal is to automatically generate API reference docs for the TypeScript SDK and include them in the Docusaurus site. We will use TypeDoc (a TypeScript documentation generator) along with the TypeDoc Markdown plugin and a Docusaurus plugin to integrate it.
	1.	Install TypeDoc and Plugins: In the website directory, add TypeDoc and the necessary plugins as dev dependencies:

npm install --save-dev typedoc typedoc-plugin-markdown docusaurus-plugin-typedoc

This installs:
	•	TypeDoc – the generator.
	•	typedoc-plugin-markdown – a plugin for TypeDoc to output Markdown instead of HTML.
	•	docusaurus-plugin-typedoc – a Docusaurus plugin that runs TypeDoc during the site build and integrates the output ? ?.

	2.	Configure the TypeDoc Plugin: Open website/docusaurus.config.js. Under the plugins section, add a configuration for docusaurus-plugin-typedoc. For example:

plugins: [
  [
    'docusaurus-plugin-typedoc',
    {
      entryPoints: ['../src/index.ts'],       // path to the TS SDK entry point
      tsconfig: '../tsconfig.json',           // path to the TS SDK tsconfig
      out: 'api',                             // output dir (docs/api)
      sidebar: { sidebarFile: 'typedoc-sidebar.js' }  // generate a sidebar file for API
      // (you can add other TypeDoc options here, like excludePrivate, etc.)
    }
  ]
],

In this example, we assume your SDK’s main file is src/index.ts in the root of the repo (adjust the path if needed). The plugin will run TypeDoc on your code using your TS config. We specify the output documentation to go into the docs/api directory (relative to the website folder). The plugin will automatically generate Markdown files for the API and even produce a sidebar configuration for those docs ?.
Note: The out: 'api' option places the generated files in website/docs/api. If not specified, the plugin by default uses docs/api as well ?. The sidebarFile option tells the plugin to create a typedoc-sidebar.js (or .json/.cjs) with the sidebar structure for the API docs.

	3.	Integrate API Docs into Sidebar: With the above config, when Docusaurus builds the site, it will generate the TypeScript API docs and a sidebar file. To include these in the site’s navigation:
	•	Import the generated sidebar in your sidebars.js. For example:

const apiSidebar = require('./docs/api/typedoc-sidebar.js');


	•	Merge it into your sidebars configuration. For instance, you might create a category in the sidebar for the TypeScript API reference and spread the items from the generated sidebar. For example:

module.exports = {
  tutorialSidebar: [ /* your existing guides */ ],
  apiSidebar: [
    {
      type: 'category',
      label: 'TypeScript SDK API',
      link: { type: 'doc', id: 'api/index' }, // link to API index page
      items: apiSidebar,
    },
  ],
};

In this setup, we define two sidebars: one for general docs (e.g. guides) and one for the API. The API sidebar is a category titled “TypeScript SDK API” whose content is all the pages generated by TypeDoc (with an index page link). The plugin’s generated typedoc-sidebar.js exports the list of API pages (classes, interfaces, etc.) which we include as items. This yields a nicely organized API section in the sidebar (with classes, interfaces grouped, etc., as TypeDoc generates). Alternatively, you can integrate the API docs into a single unified sidebar if you prefer, but separating it often keeps navigation cleaner.

	4.	Add Navbar Link to API Docs: To mimic Docusaurus’s own site navigation (which has separate sections for Docs and API), update the themeConfig.navbar in docusaurus.config.js. For example, in the navbar.items array add an entry for the API docs section:

navbar: {
  title: 'OpenSecret SDK Docs',
  items: [
    { type: 'doc', docId: 'getting-started', position: 'left', label: 'Getting Started' },
    { type: 'docSidebar', sidebarId: 'apiSidebar', position: 'left', label: 'API Reference' },
    { href: 'https://github.com/OpenSecretCloud/OpenSecret-SDK', label: 'GitHub', position: 'right' }
  ]
}

The docSidebar item will drop down or navigate to a page that shows the entire API reference sidebar. Now your top navbar has a clear separation between the guide (“Getting Started”) and the API docs, similar to Docusaurus’s own site navigation.

	5.	Run and Verify: Run the development server or build again (npm run start or npm run build in website). The Docusaurus TypeDoc plugin will execute TypeDoc as part of the build. You should see the TypeScript API documentation pages generated under the /docs/api/ route. For example, http://localhost:3000/docs/api/ should load the index of the TypeScript SDK API docs ?. All public classes, interfaces, etc., from your SDK should appear in the sidebar under the “TypeScript SDK API” section. (If you have many classes, the plugin will group them, and you can adjust grouping via TypeDoc options as needed.)
The TypeDoc generation is triggered automatically during the Docusaurus build process – you don’t need to run TypeDoc manually each time. (Internally, the plugin invokes TypeDoc when you run the Docusaurus CLI commands ?.) If desired, you can also manually trigger just the doc generation via the command npm run docusaurus generate-typedoc ?, but this is optional. In a continuous integration or Pages build, simply running the Docusaurus build will include the latest API docs.

Step 4: Prepare for Additional SDKs (Rust, Go, Python)

The documentation structure should be set up to easily incorporate API references for Rust, Go, Python SDKs in the future. Here are recommendations to achieve a scalable structure:
	•	Separate Sections per Language: Organize the docs so that each SDK’s API docs live in their own directory or section. For example, you might use docs/api/ts/ for TypeScript, docs/api/rust/ for Rust, etc., or top-level docs/ts-api, docs/rust-api folders. This way, content for each language is grouped separately. In the current setup, we used docs/api (primarily for TypeScript). You can decide to nest further (e.g., docs/api/ts/*) to differentiate once you add other languages. The structure could evolve to:

docs/
  getting-started.md
  api/
    ts/   (TypeScript API docs)
    rust/ (Rust API docs)
    go/   (Go API docs)
    python/ (Python API docs)

This ensures URLs and sidebars can be distinct (e.g. /docs/api/ts/* for TS, /docs/api/rust/* for Rust, etc.).

	•	Multiple Documentation Plugins (optional): Docusaurus allows multiple instances of the docs plugin, which can be useful if you want entirely separate sidebars and URLs for each SDK section ?. For example, you could configure one docs plugin instance for general docs, and others for each language’s API docs. Each instance can have its own path, routeBasePath, and sidebar. For instance, an instance with id: 'rust-api' could use path: 'docs/api/rust' and routeBasePath: 'rust', generating documentation at /rust/* URLs on the site ?. This approach is more advanced but can keep things very clean (the TypeScript API could live under /ts/*, Rust under /rust/*, etc., separate from the main /docs/*). If you prefer simplicity, you can also keep everything under the main docs plugin and just manage the structure with folders and sidebars.
	•	Generating Other Languages’ API Docs: Plan how to generate documentation for each language:
	•	Rust: Use rustdoc to generate documentation. The standard rustdoc output is HTML, but you can obtain a JSON output (cargo doc --no-deps --document-private-items -Z unstable-options --output-format=json) and potentially use a tool to convert that to Markdown, or use a community tool to generate MD files from Rust doc comments. There may not be an official Docusaurus plugin for Rust, so one approach is to generate static Markdown (or even HTML) and incorporate it. For instance, you could generate Rust docs as HTML and link them, but to maintain the same look and navigation, a Markdown approach is ideal. If a converter is not available, you might include key Rust docs manually for the first iteration. Ensure the Rust docs end up in the website/docs/api/rust folder (with an _category_.json or sidebar entry to organize them).
	•	Go: For Go, Godoc can output HTML. Similar to Rust, look for a way to get Markdown or use a tool like godocdown or Goldmark to produce Markdown from Go comments. Alternatively, consider using a service like pkg.go.dev for reference and link to it, while still providing a summary in your docs site. If you generate Markdown, place it under docs/api/go. If you link externally, you could just add a link in the navbar or a placeholder page.
	•	Python: Python can use Sphinx or pdoc to generate documentation. For example, pdoc3 can generate Markdown or HTML for Python modules. You might run pdoc to generate Markdown files for the Python SDK and put them in docs/api/python. There is also the possibility of using Sphinx with a Markdown builder. Choose a tool that fits your workflow; the key is to integrate the output into the Docusaurus site structure.
	•	Integrate into Docusaurus: For each new SDK:
	1.	Add any necessary build steps or plugins. (Currently, the TypeDoc plugin covers TypeScript. For other languages, you might not have a dedicated Docusaurus plugin, so you’ll handle generation outside of Docusaurus and just commit or include the generated docs in the docs folder.)
	2.	Organize the generated docs into the proper folder (docs/api/<language>).
	3.	Update sidebars.js to include the new docs. You could create a top-level category for “API Reference” and sub-categories for each language. For example:

module.exports = {
  docs: [ /* maybe your Getting Started and other guides */ ],
  api: [
    { 
      type: 'category', label: 'API Reference', collapsible: false, items: [
        {
          type: 'category', label: 'TypeScript SDK', link: { type: 'doc', id: 'api/ts/index' }, items: /* ... TS API sidebar ... */
        },
        {
          type: 'category', label: 'Rust SDK', link: { type: 'doc', id: 'api/rust/index' }, items: [ /* ...Rust docs... */ ]
        },
        // ... similarly for Go, Python
      ]
    }
  ]
};

In the navbar, you could then link to the overall “API Reference” section (or use a dropdown) rather than individual languages directly. This design would present a single API Reference menu, which when clicked or hovered, shows each SDK’s docs. It keeps navigation similar to sites like Docusaurus’s own docs (which separate sections clearly).

	•	Maintainability: Document in your repository README or contribution guide how to update the docs for each SDK. For example, for TypeScript, developers should document code via TSDoc comments and simply run the site build to update the API docs. For Rust/Go/Python, they might need to run a specific command to regenerate docs (you can create npm scripts or Makefile targets for this, e.g., npm run build:docs:rust to generate Rust markdown). By automating as much as possible, adding a new SDK’s docs becomes straightforward: just generate and drop in the files, then update the sidebar/nav.

By planning the folder structure and sidebar organization now, you ensure that adding new language SDK documentation will be a predictable process and won’t require a complete restructuring of the site.

Step 5: Ensure Clean Navigation and Developer-Friendly Setup

With the content in place, focus on navigation and ease of maintenance:
	•	Sidebar Structure: Keep the sidebar organized logically. As mentioned, you might have a clear separation between the general guides (e.g., Getting Started, usage examples) and the API reference material. Docusaurus sidebars support categories and even autogenerated structure. Leverage categories to group related pages (for example, if later you add more guide pages, group them under a “Guides” category). The use of an autogenerated sidebar for each section can simplify maintenance: “Docusaurus can create a sidebar automatically from your filesystem structure: each folder creates a sidebar category, and each file creates a doc link” ?. This means if you structure your docs folder well (one folder per SDK API, etc.), you can often use type: 'autogenerated' sidebars and not have to manually list every page. This reduces the maintenance overhead when pages are added or renamed.
	•	Top Navbar: The top navigation bar should have clearly labeled sections. For example, you might have Docs (or Guide) and API Reference as primary menus (along with a link to GitHub, etc.). Since you expect multiple SDKs, using an API Reference dropdown might be the cleanest: the top-level label “API Reference” and under it, links to “TypeScript”, “Rust”, “Go”, “Python” sections. In Docusaurus config this can be done by a navbar item with items (sub-links). This way a user can easily find the API docs for their language of choice. Initially, with only TypeScript available, you can simply have a single “API Reference” link. As others are added, convert it to a dropdown. This approach mirrors Docusaurus’s own site (which has separate sections under the navbar for Docs, API, etc., rather than one long sidebar with everything).
	•	Consistent Look and Feel: The generated API docs (from TypeDoc or others) will use the Docusaurus theme, so they should blend in with manually written docs. Ensure any Markdown generators for other languages output basic Markdown that Docusaurus can render. You might need to tweak the frontmatter or headings of generated files for consistency (for example, adding titles, or _category_.json files for grouping). The TypeDoc plugin already handles this for TypeScript API.
	•	Developer-Friendly Maintenance: Since the site is part of the repo, updating docs should be as simple as editing Markdown or updating code comments:
	•	For TypeScript, updating JSDoc/TSDoc comments in the SDK will automatically update the content in the next doc build. Encourage developers to document code thoroughly.
	•	For other languages, have a straightforward process (script) to regenerate docs. You might include these in the project’s CI or as part of release process for each SDK.
	•	Keep the Docusaurus config and structure simple: avoid too many customizations that are hard to understand. Use community plugins (like the TypeDoc plugin) to avoid reinventing wheels.
	•	Plugins and Tools Summary: To recap, the recommended plugins and tools for this setup are:
	•	@docusaurus/preset-classic – (included by default) provides docs, blog, etc. We mainly use its docs plugin.
	•	docusaurus-plugin-typedoc – runs TypeDoc and integrates TypeScript API docs ?.
	•	typedoc-plugin-markdown – allows TypeDoc to output Markdown (required by the above plugin) ?.
	•	For future SDKs: while not a plugin, tools like Rust’s rustdoc, Go’s godoc, and Python’s Sphinx/pdoc will be used to generate documentation which we then integrate. If community Docusaurus plugins or converters exist by the time you add those, leverage them. (For example, if a “docusaurus-plugin-rustdoc” or similar emerges, consider using it. If not, use custom scripts.)

By following these steps, you will have a Docusaurus documentation site in the /website directory that hosts a Getting Started guide and an automatically generated TypeScript SDK API reference, ready to deploy. The structure is designed to scale to additional SDKs (Rust, Go, Python) by adding their docs in a similar way. The navigation will remain clean and intuitive (mirroring the style of Docusaurus’s own documentation site), and the setup will be easy for developers to update and maintain over time.

Step 6: Deploy to Cloudflare Pages with a Custom Domain

Finally, you’ll deploy the static site and make it accessible on the web:
	1.	Cloudflare Pages Setup: Go to Cloudflare Pages and create a new project, connecting it to your GitHub repository (select the OpenSecret-SDK repo). In the build settings, select the Docusaurus preset if available, or manually specify:
	•	Build command: npm run build (inside the website directory).
	•	Build output directory: website/build (or just build if the project root is website). If you use the framework preset for Docusaurus, Cloudflare will auto-detect these settings for you ?.
	•	Set the production branch to main (or whichever branch you want to deploy from) ?.
Cloudflare Pages will then install dependencies and run the build. The Docusaurus build outputs static files into the build folder, which Cloudflare will serve. After the first deployment, you’ll get a default your-project.pages.dev URL for preview ?.
	2.	Use a Custom Domain: In the Cloudflare Pages dashboard for your project, go to Settings > Custom Domains and add your desired custom domain (e.g. docs.opensecretcloud.com or similar). You must own this domain and have it managed in Cloudflare DNS. Cloudflare will guide you to either update your DNS or, if the domain is already in Cloudflare, it will provision the domain on Pages automatically ? ?. Once done, your site will be accessible at the custom domain.
Tip: Ensure the url in docusaurus.config.js is updated to match the custom domain (and include the https:// protocol). This is used in generating site metadata and links.
	3.	Continuous Deployment: With the Pages integration, every push to your repo’s branch will trigger a rebuild and deployment of the docs site ?. This means documentation updates (or SDK comment updates that affect the API docs) will go live after committing. You can protect the main branch or use pull requests as needed; Cloudflare Pages also supports preview deployments for PRs, so you can review changes before merging ?.
	4.	Verify Post-Deploy: Visit the custom domain after deployment. Check that the “Getting Started” page and the TypeScript API reference are functioning and that links work. Verify the sidebar toggles, search (if you enabled DocSearch or similar), and overall styling. Because Docusaurus is a single-page app, ensure that direct navigation to deep links (like .../docs/api/ts/SomeClass) also works (they should, by default).

By hosting on Cloudflare Pages, you get fast global CDN distribution. The site is entirely static, so it fits perfectly into Pages’ model. Cloudflare Pages also makes it easy to roll back if needed and to monitor deployments. With a custom domain, developers visiting the docs will see a polished URL.

?

References:
	•	Docusaurus TypeDoc Plugin Quick Start – demonstrating how to install and configure the plugin for generating TypeDoc pages ? ?. This includes specifying entry points and tsconfig for the TypeScript API docs.
	•	Docusaurus TypeDoc Plugin usage – confirming that running the Docusaurus build or dev server will auto-generate the API documentation pages ? and make them available under the /docs/api path ?.
	•	Docusaurus Sidebar/Structure – noting that Docusaurus can auto-generate a sidebar from the docs folder structure for easy maintenance ?.
	•	Cloudflare Pages Documentation – showing the build settings for Docusaurus (build command npm run build and output build folder) and the automatic deployment on commits ? ?. This ensures our static site is correctly built and served on Cloudflare Pages with minimal configuration.
